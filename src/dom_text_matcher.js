// Generated by CoffeeScript 1.6.3
(function() {
  window.DomTextMatcher = (function() {
    DomTextMatcher.prototype.setRootNode = function(rootNode) {
      return this.mapper.setRootNode(rootNode);
    };

    DomTextMatcher.prototype.setRootId = function(rootId) {
      return this.mapper.setRootId(rootId);
    };

    DomTextMatcher.prototype.setRootIframe = function(iframeId) {
      return this.mapper.setRootIframe(iframeId);
    };

    DomTextMatcher.prototype.setRealRoot = function() {
      return this.mapper.setRealRoot();
    };

    DomTextMatcher.prototype.documentChanged = function() {
      return this.mapper.documentChanged();
    };

    DomTextMatcher.prototype.scan = function() {
      var data, t0, t1;
      t0 = this.timestamp();
      data = this.mapper.scan();
      t1 = this.timestamp();
      return {
        time: t1 - t0,
        data: data
      };
    };

    DomTextMatcher.prototype.getDefaultPath = function() {
      return this.mapper.getDefaultPath();
    };

    DomTextMatcher.prototype.searchExact = function(pattern, distinct, caseSensitive, path) {
      if (distinct == null) {
        distinct = true;
      }
      if (caseSensitive == null) {
        caseSensitive = false;
      }
      if (path == null) {
        path = null;
      }
      if (!this.pm) {
        this.pm = new window.DTM_ExactMatcher;
      }
      this.pm.setDistinct(distinct);
      this.pm.setCaseSensitive(caseSensitive);
      return this.search(this.pm, pattern, null, path);
    };

    DomTextMatcher.prototype.searchRegex = function(pattern, caseSensitive, path) {
      if (caseSensitive == null) {
        caseSensitive = false;
      }
      if (path == null) {
        path = null;
      }
      if (!this.rm) {
        this.rm = new window.DTM_RegexMatcher;
      }
      this.rm.setCaseSensitive(caseSensitive);
      return this.search(this.rm, pattern, null, path);
    };

    DomTextMatcher.prototype.searchFuzzy = function(pattern, pos, caseSensitive, path, options) {
      var _ref, _ref1;
      if (caseSensitive == null) {
        caseSensitive = false;
      }
      if (path == null) {
        path = null;
      }
      if (options == null) {
        options = {};
      }
      this.ensureDMP();
      this.dmp.setMatchDistance((_ref = options.matchDistance) != null ? _ref : 1000);
      this.dmp.setMatchThreshold((_ref1 = options.matchThreshold) != null ? _ref1 : 0.5);
      this.dmp.setCaseSensitive(caseSensitive);
      return this.search(this.dmp, pattern, pos, path, options);
    };

    DomTextMatcher.prototype.normalizeString = function(string) {
      return string.replace(/\s{2,}/g, " ");
    };

    DomTextMatcher.prototype.searchFuzzyWithContext = function(prefix, suffix, pattern, expectedStart, expectedEnd, caseSensitive, path, options) {
      var analysis, charRange, expectedPrefixStart, expectedSuffixStart, k, len, mappings, match, matchThreshold, obj, patternLength, prefixEnd, prefixResult, remainingText, suffixResult, suffixStart, v, _i, _len, _ref, _ref1, _ref2, _ref3;
      if (expectedStart == null) {
        expectedStart = null;
      }
      if (expectedEnd == null) {
        expectedEnd = null;
      }
      if (caseSensitive == null) {
        caseSensitive = false;
      }
      if (path == null) {
        path = null;
      }
      if (options == null) {
        options = {};
      }
      this.ensureDMP();
      if (!((prefix != null) && (suffix != null))) {
        throw new Error("Can not do a context-based fuzzy search with missing context!");
      }
      len = this.mapper.getDocLength();
      expectedPrefixStart = expectedStart != null ? expectedStart - prefix.length : len / 2;
      this.dmp.setMatchDistance((_ref = options.contextMatchDistance) != null ? _ref : len * 2);
      this.dmp.setMatchThreshold((_ref1 = options.contextMatchThreshold) != null ? _ref1 : 0.5);
      prefixResult = this.dmp.search(this.mapper.corpus, prefix, expectedPrefixStart);
      if (!prefixResult.length) {
        return {
          matches: []
        };
      }
      prefixEnd = prefixResult[0].end;
      patternLength = pattern != null ? pattern.length : (expectedStart != null) && (expectedEnd != null) ? expectedEnd - expectedStart : 64;
      remainingText = this.mapper.corpus.substr(prefixEnd);
      expectedSuffixStart = patternLength;
      suffixResult = this.dmp.search(remainingText, suffix, expectedSuffixStart);
      if (!suffixResult.length) {
        return {
          matches: []
        };
      }
      suffixStart = prefixEnd + suffixResult[0].start;
      charRange = {
        start: prefixEnd,
        end: suffixStart
      };
      matchThreshold = (_ref2 = options.patternMatchThreshold) != null ? _ref2 : 0.5;
      analysis = this.analyzeMatch(pattern, charRange, true);
      if ((pattern == null) || analysis.exact || (analysis.comparison.errorLevel <= matchThreshold)) {
        mappings = this.mapper.getMappingsForCharRange(prefixEnd, suffixStart);
        match = {};
        _ref3 = [charRange, analysis, mappings];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          obj = _ref3[_i];
          for (k in obj) {
            v = obj[k];
            match[k] = v;
          }
        }
        return {
          matches: [match]
        };
      }
      return {
        matches: []
      };
    };

    function DomTextMatcher(domTextMapper) {
      this.mapper = domTextMapper;
    }

    DomTextMatcher.prototype.search = function(matcher, pattern, pos, path, options) {
      var fuzzyComparison, matches, result, t0, t1, t2, t3, textMatch, textMatches, _fn, _i, _len, _ref,
        _this = this;
      if (path == null) {
        path = null;
      }
      if (options == null) {
        options = {};
      }
      if (pattern == null) {
        throw new Error("Can't search for null pattern!");
      }
      pattern = pattern.trim();
      if (pattern == null) {
        throw new Error("Can't search an for empty pattern!");
      }
      fuzzyComparison = (_ref = options.withFuzzyComparison) != null ? _ref : false;
      t0 = this.timestamp();
      if (path != null) {
        this.scan();
      }
      t1 = this.timestamp();
      textMatches = matcher.search(this.mapper.corpus, pattern, pos, options);
      t2 = this.timestamp();
      matches = [];
      _fn = function(textMatch) {
        var analysis, k, mappings, match, obj, v, _j, _len1, _ref1;
        analysis = _this.analyzeMatch(pattern, textMatch, fuzzyComparison);
        mappings = _this.mapper.getMappingsForCharRange(textMatch.start, textMatch.end);
        match = {};
        _ref1 = [textMatch, analysis, mappings];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          obj = _ref1[_j];
          for (k in obj) {
            v = obj[k];
            match[k] = v;
          }
        }
        matches.push(match);
        return null;
      };
      for (_i = 0, _len = textMatches.length; _i < _len; _i++) {
        textMatch = textMatches[_i];
        _fn(textMatch);
      }
      t3 = this.timestamp();
      result = {
        matches: matches,
        time: {
          phase0_domMapping: t1 - t0,
          phase1_textMatching: t2 - t1,
          phase2_matchMapping: t3 - t2,
          total: t3 - t0
        }
      };
      return result;
    };

    DomTextMatcher.prototype.timestamp = function() {
      return new Date().getTime();
    };

    DomTextMatcher.prototype.analyzeMatch = function(pattern, charRange, useFuzzy) {
      var expected, found, result;
      if (useFuzzy == null) {
        useFuzzy = false;
      }
      expected = this.normalizeString(pattern);
      found = this.normalizeString(this.mapper.getContentForCharRange(charRange.start, charRange.end));
      result = {
        found: found,
        exact: found === expected
      };
      if (!result.exact) {
        result.exactExceptCase = expected.toLowerCase() === found.toLowerCase();
      }
      if (!result.exact && useFuzzy) {
        this.ensureDMP();
        result.comparison = this.dmp.compare(expected, found);
      }
      return result;
    };

    DomTextMatcher.prototype.ensureDMP = function() {
      if (this.dmp == null) {
        if (window.DTM_DMPMatcher == null) {
          throw new Error("DTM_DMPMatcher is not available. Have you loaded the text match engines?");
        }
        return this.dmp = new window.DTM_DMPMatcher;
      }
    };

    return DomTextMatcher;

  })();

}).call(this);

/*
//@ sourceMappingURL=dom_text_matcher.map
*/
